// Основним механізмом управління станом в Go є,
// комунікачія за допомогою каналів. Ми вже побачили
// це на прикладі "[натовпу робітників](worker-pools)".
// Але, існують і інші способи управління станом, наприклад
// зараз ми познайомимось з  пакунком `sync/atomic` для
// _атомарних лічильників_ достуа до яких є у клькох горутин.

package main

import "fmt"
import "time"
import "sync/atomic"

func main() {

    // Ось ми використаємо беззнакове ціле число для представлення
    // нашого (завжди позитивного) лічильника.
    var ops uint64

    // Для симуляції одночасних оновлень, ми запускаємо 50
    // горутин кожна з яких буде збільшувати лічильник на одиницю
    // кожної мілісекунди.
    for i := 0; i < 50; i++ {
        go func() {
            for {
                // Для автоматичного інкременту ми користуємось
                // методом `AddUint64`, якому даємо вказівник на
                // комірку памяті де наш `ops` розташовується.
                atomic.AddUint64(&ops, 1)

                // Мініпауза між оновленнями.
                time.Sleep(time.Millisecond)
            }
        }()
    }

    // Чекаємо близько 1єї секунди, надаючи `ops` акумулювати деяке
    // значення.
    time.Sleep(time.Second)

    // Для того щоб безпечно використовувати лічильник який
    // все ще оновлюється іншими горутинами, ми отримуємо копію
    // значення за допомогою `LoadUint64` і передаємо її `opsFinal`
    // Так само як і в попередньому прикладі інкрементації, нам
    // потрібно надати вказівник на комірку памяти щоб `LoadUint64`
    // могла зняти копію цього значення.
    opsFinal := atomic.LoadUint64(&ops)
    fmt.Println("ops:", opsFinal)
}
