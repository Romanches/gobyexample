// Одна з ідіом Go, це отримувати помилки за допомогою чітко
// вказаних данних що повертаються (з функцій). Це виділяє Go
// на фоні _виключень_ (_exceptions_) ви використовуються у
// Java чи Ruby, або в порівнянні з перевантаженням одиночного
// результату та помилки, що інколи використовується в С. Підхід Go,
// спрощує задачі спостереження функцій що повертають помилки і
// обробляє їх тими ж споссобами що й інші не-помилкові задачі.
package main

import "errors"
import "fmt"

// За погодженнням, помилкою вказується останнє з значень що повертаються, що надодачу має тип `error` (встроєний інтерфейс).
func f1(arg int) (int, error) {
    if arg == 42 {

        // Конструкція `errors.New` створбє базове значення помилки
        // з заданним повідомленням.
        return -1, errors.New("can't work with 42")
    }

    // А  `nil` значення на позиції помилки вказує на те,
    // що ніякої помилки не виникло.
    return arg + 3, nil
}

// Можливо використовувати і інші типи як помилки (`error`s)
// (якщо ці типи реалізують метод `Error()` на собі).
// Ось приклад який використовує власний тип помилки що
// ясно репрезентує помилку аргумента.
type argError struct {
    arg  int
    prob string
}

func (e *argError) Error() string {
    return fmt.Sprintf("%d - %s", e.arg, e.prob)
}

func f2(arg int) (int, error) {
    if arg == 42 {

        // У цьому випадку ми вкористовуємо синтакс `&argError`
        // щоб створити нову структуру забезпечуючи її значеннями
        // для двох полів `arg` та `prob`.
        return -1, &argError{arg, "can't work with it"}
    }
    return arg + 3, nil
}

func main() {

    // Ци два цикли тестують кожну знаших функцій що повертають
    // помилки. Зауважне, що однолінійна перевірка помилки поряд з
    // оператором умовного розгалуження `if` це одна з ідіом Go.
    for _, i := range []int{7, 42} {
        if r, e := f1(i); e != nil {
            fmt.Println("f1 failed:", e)
        } else {
            fmt.Println("f1 worked:", r)
        }
    }
    for _, i := range []int{7, 42} {
        if r, e := f2(i); e != nil {
            fmt.Println("f2 failed:", e)
        } else {
            fmt.Println("f2 worked:", r)
        }
    }

    // Якщо ви хочете використати данні вашої помилки программно
    // необхідно буде дістати помилку як зразок (instance) вашого
    // типу, використовуючи заяву типу (type assertion).
    _, e := f2(42)
    if ae, ok := e.(*argError); ok {
        fmt.Println(ae.arg)
        fmt.Println(ae.prob)
    }
}
