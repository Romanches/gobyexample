// Go надає вбудовану підтримку [регулярних виразів](https://uk.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D1%83%D0%BB%D1%8F%D1%80%D0%BD%D0%B8%D0%B9_%D0%B2%D0%B8%D1%80%D0%B0%D0%B7).
// Ось, деякі приклади задач що так чи інакше пов’язані з регулярними виразами.

package main

import "bytes"
import "fmt"
import "regexp"

func main() {

    // Тестуємо чи наш шаблон співпадає з рядком.
    match, _ := regexp.MatchString("p([a-z]+)ch", "peach")
    fmt.Println(match)

    // Рядком вище - ми прямо використали викорастали рядковий шаблон,
    // але для інших задач пов’язаних з ругелярними виразами,
    // нам необхідно буде `Compile` (скомпілювати) рядковий
    // шаблон у `Regexp` структуру.
    r, _ := regexp.Compile("p([a-z]+)ch")

    // На таких структура доступно чимало різних методоів:
    // ось наприклад співставлення з рядком, що ми бачили в
    // першому прикладі.
    fmt.Println(r.MatchString("peach"))

    // А тут ми знаходимо збіг для нашого регулярного виразу.
    fmt.Println(r.FindString("peach punch"))

    // Цей приклад теж знайде збіги, але поверне початковий
    // та кінцевий індекси для збіру, замість рядка що збігається.
    fmt.Println(r.FindStringIndex("peach punch"))

    // Варіації методів `Submatch` включать також інформацію про
    // повні збіги та часткові збіги в межах повних. Для прикладу -
    // це поверне інформацію про регулярні вирази `p([a-z]+)ch`
    // та `([a-z]+)`.
    fmt.Println(r.FindStringSubmatch("peach punch"))

    // Схожим чином - ми отримаємо індекс повного і
    // часткового збігу.
    fmt.Println(r.FindStringSubmatchIndex("peach punch"))

    // Варіації методів `All` аплікуються до усіх збігів, а не лише
    // до першого. Приклад знаходження усіх збігів.
    fmt.Println(r.FindAllString("peach punch pinch", -1))

    // Варіції `All` також доступні і іншим методам що ми вже бачили.
    fmt.Println(r.FindAllStringSubmatchIndex(
        "peach punch pinch", -1))

    // Другий аргумент - заданий додатнім цілим числом, допомогає
    // обмежити кількість збігів - цим числом.
    fmt.Println(r.FindAllString("peach punch pinch", 2))

    // Приклади що ми розглянули отримуються рядковий параметр і
    // використовують імя типу `MatchString`, але ми також можемо
    // надати аргументом і зріз байтів - `[]byte` та прибрати `String`
    // з імені методу - і отримаємо аналогічний метод що буде працювати з
    // зрізами байтів.
    fmt.Println(r.Match([]byte("peach")))

    // Створюєчи константи регулярних виразів - ви можете
    // використовувати варіацію `MustCompile` замість `Compile`.
    // Простий `Compile` не спрацює з константом оскільки повертає
    // два значення.
    r = regexp.MustCompile("p([a-z]+)ch")
    fmt.Println(r)

    // Пакунок `regexp` можна використовувати для заміни чаткових-збігів
    // рядків іншими значеннями.
    fmt.Println(r.ReplaceAllString("a peach", "<fruit>"))

    // Варіація  методів `Func` дозволяє трансформувати текст заданою функцією.
    in := []byte("a peach")
    out := r.ReplaceAllFunc(in, bytes.ToUpper)
    fmt.Println(string(out))
}
