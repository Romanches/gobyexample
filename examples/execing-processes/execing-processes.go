// У попередньому прикладі ми розглянули
// [запуск сторонніх процесів](spawning-processes).
// Ми робимо це коли хочемо, щоб запущений процес
// був доступний нашому Go процесу. Але інколи, все чого ми
// бажаєм - це лише повністю замінити поточний Goпроцес
// іншим (можливо навіть не "Go-процесом"). Ми скористаємось
// реалізацією Go класичного системного виклику [exec](http://en.wikipedia.org/wiki/Exec_(operating_system)).

package main

import "syscall"
import "os"
import "os/exec"

func main() {

    // Для прикладу, ми виконаємо `ls`. Go потребує абсолютний
    // шлях до програми що ми хочемо виконати, отож ми скористаємось
    // `exec.LookPath` задля пошуку (і можливо ми знайдемо її як `/bin/ls`).
    binary, lookErr := exec.LookPath("ls")
    if lookErr != nil {
        panic(lookErr)
    }

    // `Exec` потребує аргументу у вигляді [`зрізу`](slices)
    // (напротивагу одному великому рядку). Ми надамо `ls`
    // кілька звичайних (для цієї команди) аргументів.
    args := []string{"-h", "-o"}

    // `Exec` також необхідно мати дял використання
    // [змінні оточення](environment-variables). Ми ж надамо йому
    // наше поточне середовище.
    env := os.Environ()

    // Ось власне виклик `syscall.Exec`. Якщо виклик успішний, виконання нашого процесу завершиться і буде замінено процесом `/bin/ls -a -l -h`.
    // Якщо виникне помилка то ми отримаємо [паніку](panic) з текстом помилки.
    execErr := syscall.Exec(binary, args, env)
    if execErr != nil {
        panic(execErr)
    }
}
